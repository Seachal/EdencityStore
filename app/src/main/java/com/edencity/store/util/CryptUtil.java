package com.edencity.store.util;import java.io.ByteArrayOutputStream;import java.security.MessageDigest;import java.util.Random;import javax.crypto.Cipher;import javax.crypto.spec.SecretKeySpec;public class CryptUtil {	private static final char[] HEX_DIGITS = { '0', '1', '2', '3', '4', '5',		'6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };	public static String bytesToHexString(byte[] bytes) {		StringBuilder sb = new StringBuilder(bytes.length * 2);		for (int i = 0; i < bytes.length; i++) {			sb.append(HEX_DIGITS[(bytes[i] & 0xf0) >> 4]);			sb.append(HEX_DIGITS[(bytes[i] & 0x0f)]);		}		return sb.toString();	}		public static String MD5(String s) {        try {            MessageDigest mdInst = MessageDigest.getInstance("MD5");            // 使用指定的字节更新摘要            mdInst.update(s.getBytes());            // 获得密文            byte[] md = mdInst.digest();            // 把密文转换成十六进制的字符串形式            if(md!=null)            	return bytesToHexString(md);        } catch (Exception e) {            e.printStackTrace();        }        return null;    }	public static String SHA1(String s) {        try {            MessageDigest mdInst = MessageDigest.getInstance("SHA-1");            // 使用指定的字节更新摘要            mdInst.update(s.getBytes("UTF-8"));            // 获得密文            byte[] md = mdInst.digest();            // 把密文转换成十六进制的字符串形式            if(md!=null)            	return bytesToHexString(md);        } catch (Exception e) {            e.printStackTrace();        }        return null;    }	public static String getRandomString(int length) { //length表示生成字符串的长度	    String base = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";   //生成字符串从此序列中取	    Random random = new Random();   	    StringBuffer sb = new StringBuffer();   	    for (int i = 0; i < length; i++) {   	        int number = random.nextInt(base.length());   	        sb.append(base.charAt(number));   	    }	    return sb.toString();   	 }	public static String getRandomNumber(int length) { //length表示生成字符串的长度		String base = "0123456789";   //生成字符串从此序列中取		Random random = new Random();		StringBuffer sb = new StringBuffer();		for (int i = 0; i < length; i++) {			int number = random.nextInt(base.length());			sb.append(base.charAt(number));		}		return sb.toString();	}	protected static byte[] hexStringToBytes(String text) {			ByteArrayOutputStream baos = new ByteArrayOutputStream(text.length() / 2);		char c;		int v=0;		for (int i = 0; i < text.length(); i += 2) {			v=0;			for(int j=0;j<2;j++){				c=text.charAt(i+j);				if(c>='0' && c<='9'){					v+=(c-'0');				}else if(c>='a' && c<='f'){					v+=(c-'a');				}				if(j==0) v*=16;			}			baos.write((byte)v);		}		return baos.toByteArray();	}		/**	 * 密钥算法	 */	public static final String aes_key_algorithm = "AES";	/**	 * 加解密算法/工作模式/填充方式	 */	public static final String cipher_algorithm = "AES/ECB/PKCS5Padding";	public static byte[] AESEncrypt(String key, String msg) {		Cipher cipher = null;		try {			SecretKeySpec skey = new SecretKeySpec(key.getBytes(), 0, 16,aes_key_algorithm);			cipher = Cipher.getInstance(cipher_algorithm);// 创建密码器			cipher.init(Cipher.ENCRYPT_MODE, skey);			return cipher.doFinal(msg.getBytes("utf-8"));		} catch (Exception e) {			e.printStackTrace();		}		return null;	}	public static byte[] AESDecrypt(String key, byte[] msg) {		Cipher cipher = null;		try {			SecretKeySpec skey = new SecretKeySpec(key.getBytes(), 0, 16,aes_key_algorithm);			cipher = Cipher.getInstance(cipher_algorithm);// 创建密码器			cipher.init(Cipher.DECRYPT_MODE, skey);// 初始化			return cipher.doFinal(msg);		} catch (Exception e) {			e.printStackTrace();			return null;		}	}		public static String AESDecrypt(String key, String msg){		try{			byte[] ret= AESDecrypt(key, asBin(msg));			return new String(ret,"utf-8");		}catch(Exception e){			e.printStackTrace();		}		return null;	}		/**	 * 将字节数组转换成16进制字符串	 * 	 * @param buf	 * @return	 */	public static String asHex(byte buf[]) {		StringBuffer strbuf = new StringBuffer(buf.length * 2);		int i;		for (i = 0; i < buf.length; i++) {			if (((int) buf[i] & 0xff) < 0x10)// 小于十前面补零				strbuf.append("0");			strbuf.append(Long.toString((int) buf[i] & 0xff, 16));		}		return strbuf.toString();	}	/**	 * 将16进制字符串转换成字节数组	 * 	 * @param src	 * @return	 */	public static byte[] asBin(String src) {		if (src.length() < 1)			return null;		byte[] encrypted = new byte[src.length() / 2];		for (int i = 0; i < src.length() / 2; i++) {			int high = Integer.parseInt(src.substring(i * 2, i * 2 + 1), 16);// 取高位字节			int low = Integer.parseInt(src.substring(i * 2 + 1, i * 2 + 2), 16);// 取低位字节			encrypted[i] = (byte) (high * 16 + low);		}		return encrypted;	}}